<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      ORAM is slow! ... is it? &middot; Celeste
    
  </title>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <link rel="icon" type="image/png" sizes="192x192" href="/favicon.png">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/apple-touch-icon.png">
  
  <link rel="alternate" type="application/atom+xml" title="Celeste" href="/atom.xml">


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$',  right: '$',  display: false}
      ]
    });
  });
</script>

</head>


  <body>
    <nav class="nav-main">
      <ul>
        <li class="hvr-underline-reveal"><a href="/about/">about</a></li>
        <li class="logo"><a class="hvr-ripple-out" href="/">C</a></li>
        <li class="hvr-underline-reveal"><a href="/blog/">blog</a></li>
        <li class="hvr-underline-reveal"><a href="/projects/">project</a></li>
      </ul>
    </nav>

    <div class="container content">
      <main>
        <article class="post">
  <h1 class="post-title">ORAM is slow! ... is it?</h1>
  <time datetime="2025-02-12T00:00:00-08:00" class="post-date">12 Feb 2025</time>
  <p>In 2014, the open-source encrypted messaging service Signal began exploring a feature called Private Contact Discovery (PCD). In this post, we trace the long path Signal took to implement PCD in a practical way, ultimately reducing the server infrastructure from hundreds of machines down to just a handful (exact numbers to be confirmed).</p>

<h4 id="whats-private-contact-discovery">What’s Private Contact Discovery</h4>
<p>Private Contact Discovery (PCD) allows users to find out which of their contacts are already registered on a service—such as a messaging app—without revealing their entire address book to the server. Concretely:</p>
<ol>
  <li>Client has a set of data, called <code class="language-plaintext highlighter-rouge">clientContacts</code></li>
  <li>Server has a set of data, called <code class="language-plaintext highlighter-rouge">registeredUsers</code></li>
  <li>A function <code class="language-plaintext highlighter-rouge">findRegisteredUsers</code> that access both set of data, and finally return the intersection of both</li>
</ol>

<p>In addition, PCD has a few requirements</p>
<ol>
  <li>Server learns nothing about clients’ contacts that haven’t registered</li>
  <li>Server learns nothing about clients’ contacts that have registered</li>
  <li>Clients learns nothing about registered users, except those are their contacts</li>
  <li>Implementation practical with 10 million registered users</li>
</ol>

<p><strong>Current Approach</strong>: As of the time covered in this post, a common method to fulfill these requirements uses a trusted execution environment (TEE) such as Intel SGX, which isolates the data from the host operating system to ensure privacy.</p>

<h2 id="2014-no-solution-works">2014: No Solution Works</h2>
<p>In a <a href="https://signal.org/blog/contact-discovery/">2014 blog post</a>  Signal detailed several methods they considered for providing a practical PCD for tens of millions of users with limited download sizes (roughly 2MB). Unfortunately, they found each approach either leaked too much information or was computationally infeasible:</p>
<ol>
  <li>Hash: Because there are only around $10^{10}$ possible phone numbers, the “preimage space” is too small—an attacker could brute force the hashed values.</li>
  <li>Bloom Filters and Encrypted Bloom Filters: A single Bloom filter for 10 million registered users would be ~40MB, making it too large for routine download to mobile devices.</li>
  <li>Sharded Bloom Filters: Splitting the data into multiple filters either reveals too much information about individual queries or still involves large data transfers, yielding minimal privacy benefits at significant complexity.</li>
  <li>Private Set Intersection: Traditional protocols would require the server to perform billions of RSA operations for each client, which is computationally overwhelming.</li>
</ol>

<h2 id="2017-linear-scan-oram-with-sgx">2017: Linear Scan ORAM with SGX</h2>
<p>Let’s fast forward to 2017, Signal team has finally founded a solution to the PCD problem that satisfy all three requirements mentioned above, and it’s through a combination of SGX and linear scan ORAM.</p>
<h3 id="whats-sgx">What’s SGX</h3>
<p>Intel Software Guard Extensions (SGX) provides a hardware-based security feature that enables trusted execution environments (TEEs), known as enclaves, within a system’s memory. Key SGX properties include:</p>
<ol>
  <li><strong>Attestation</strong>: Confirms that the code running inside the enclave matches the expected code.</li>
  <li><strong>Secure Memory</strong> – Creates an Enclave Page Cache (EPC) that even the operating system cannot see the data (encrypted or not) stored here.</li>
  <li><strong>Memory Encryption</strong> – Automatically encrypts and decrypts data in untrusted memory, preventing unauthorized access or tampering.
<em>TODO: add some summarization here</em></li>
</ol>

<h3 id="signals-solution">Signal’s solution</h3>
<p>Signal’s solution includes two parts</p>
<ol>
  <li>build an oblivious hash table on <code class="language-plaintext highlighter-rouge">clientContacts</code></li>
  <li>do a linear scan on <code class="language-plaintext highlighter-rouge">registeredUsers</code>. For each registered user, the enclave would do a lookup in the oblivious hash table and update the table for mark a hit or miss.</li>
</ol>

<p>Both data structures are stored in untrusted memory, but all read/write operations are performed inside the secure SGX enclave. This design ensures that neither the server nor the operating system can infer details about the intersection of contacts.</p>

<p>To help people better understand, we will explain on the oblivious hash table in the later section, and let’s assume we have a normal hash table for now.</p>

<h4 id="linear-scan-on-registered-users">Linear Scan on Registered Users</h4>
<p>A straightforward way to discover matches is to iterate over all entries in <code class="language-plaintext highlighter-rouge">registeredUsers</code> and check each one against the clientContacts hash table:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private List&lt;Long&gt; findRegisteredUsers(List&lt;Long&gt; registeredUsers,
                                       Set&lt;Long&gt; clientContacts)
{
  List&lt;Long&gt; results = new LinkedList&lt;&gt;();

  for (long registeredUser : registeredUsers) {
    if (clientContacts.contains(registeredUser)) {
      results.add(registeredUser);
    }
  }

  return results;
}
</code></pre></div></div>
<p>Since this code runs within the enclave, the OS only sees that each entry of <code class="language-plaintext highlighter-rouge">registeredUsers</code> is accessed once. It cannot tell which entry results in a contacts match, thus preventing the information leakage on the <code class="language-plaintext highlighter-rouge">registeredUsers</code> side.</p>

<h4 id="why-a-standard-hash-table-wont-work">Why a Standard Hash Table Won’t Work</h4>

<p>Consider the case where we use a normal hash table. When constructing the hash table, the OS can easily see which memory slots are written and which are not. This means that later, when <code class="language-plaintext highlighter-rouge">findRegisteredUsers</code> performs a lookup, the OS knows exactly whether it is a match or a miss.</p>

<p>Additionally, since the server knows which entry in <code class="language-plaintext highlighter-rouge">registeredUsers</code> is being checked at any given time, it can infer the user’s contacts.</p>

<h4 id="what-is-an-oblivious-hash-table">What Is an Oblivious Hash Table?</h4>
<p>Instead of a normal hash table, we need one additional feature: the OS should not be able to determine whether a lookup results in a hit or a miss.</p>

<p>To achieve this, we must touch all possible memory locations in the client’s contact hash table once, storing actual contacts in real memory locations and using dummy entries elsewhere so that the OS cannot distinguish between them.</p>

<p>Although the construction process is expensive, once built, the OS cannot determine whether a lookup results in a match or a miss in near native time.</p>
<h4 id="complexity">Complexity</h4>
<p>As one can see, the expensive part of this method is the cost for building the oblivious hash table and the cost for doing a linear scan on the <code class="language-plaintext highlighter-rouge">registeredUsers</code> database.  <code class="language-plaintext highlighter-rouge">registeredUsers</code> database is the bigger block here with 10 million entires.</p>

<h2 id="2022-faster-and-more-efficient-with-path-oram">2022: Faster and More Efficient with Path ORAM</h2>
<p>Fast forward to 2022—Signal has surpassed 100 million downloads and urgently needs a faster solution. In 2017, a linear scan was necessary to conceal database access patterns from the server. However, Path ORAM offers a significantly more efficient alternative while being relatively straightforward to implement.</p>

<p>This new solution includes:</p>
<ol>
  <li>using Path ORAM to store the <code class="language-plaintext highlighter-rouge">registeredUsers</code> database,</li>
  <li>iterate through <code class="language-plaintext highlighter-rouge">clientContacts</code> and do a binary search in the <code class="language-plaintext highlighter-rouge">registeredUsers</code> database for every entry.</li>
</ol>

<p>In this blog (<em>TODO: link to the intro to oram blog</em>) we described how Path ORAM works. Here, we focus on how Path ORAM is constructed and applied to this problem:</p>
<ol>
  <li>sort all <code class="language-plaintext highlighter-rouge">registeredUsers</code> based on their phone numbers, and assign the index to that specific user.</li>
  <li>assign a leaf node for each <code class="language-plaintext highlighter-rouge">registeredUsers</code> and initialize the ORAM</li>
  <li>whenever checking a <code class="language-plaintext highlighter-rouge">clientContacts</code>, do a binary search in <code class="language-plaintext highlighter-rouge">registeredUsers</code> since the users are sorted</li>
</ol>

<p>By leveraging Path ORAM as the underlying framework, we eliminate the need for linear scans while ensuring that all access patterns remain hidden, even when the database is stored in untrusted memory.</p>

<h4 id="complexity-1">Complexity</h4>
<p>Assume 1 billion of registered users. In the previous linear scan solution, checking registeredUsers with 1 billion entries required 1 billion operations. With Path ORAM:</p>
<ol>
  <li>Accessing the <code class="language-plaintext highlighter-rouge">registeredUsers</code> database involves ~30 reads and 30 writes per lookup, as a binary tree with 2 billion nodes has ~30 levels.</li>
  <li>Performing a binary search for each <code class="language-plaintext highlighter-rouge">clientContacts</code> entry requires ~30 database accesses.
Thus, the total number of memory accesses is approximately 1,800—a drastic improvement compared to the original 1 billion.</li>
</ol>

<h2 id="the-final-chapter-a-decade-of-private-contact-discovery">The Final Chapter: A Decade of Private Contact Discovery</h2>
<p>After 10 years, private contact discovery finally has a near-native implementation. While ORAM is undeniably slower than non-private solutions, its performance has often been misunderstood—exaggerated as impractically slow.</p>

<p>Signal had already explored Path ORAM in 2017, but due to an incorrect implementation and lack of optimization, they underestimated its potential. Now, we present Oblivious STL, a standardized, optimized implementation that helps the broader audience understand the true cost of privacy—and how feasible it really is.</p>


</article>
      </main>

      <footer class="footer">
        <small>
            <span class="copyright"><i class="fa fa-copyright"></i> 2015-<time datetime="2025-02-17T15:32:19-08:00">2025</time> Nico Elayda</span> &middot;
            <span>Powered by <a href="http://jekyllrb.com/">Jekyll</a></span>
        </small>
        <div class="ftr-links">
          <a href="https://github.com/nicoelayda"><i class="fa fa-github-alt"></i></a>
          <a href="https://twitter.com/nicoelayda"><i class="fa fa-twitter"></i></a>
        </div>
      </footer>
    </div>

  </body>
</html>
