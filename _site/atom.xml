<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Celeste</title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000"/>
 <updated>2025-02-17T15:32:19-08:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Nico Elayda</name>
   <email>nico@elayda.com</email>
 </author>

 
 <entry>
   <title>What is Oblivious Algorithms</title>
   <link href="http://localhost:4000/blog/2025/02/17/intro-to-oram/"/>
   <updated>2025-02-17T00:00:00-08:00</updated>
   <id>http://localhost:4000/blog/2025/02/17/intro-to-oram</id>
   <content type="html">&lt;p&gt;When one is using cloud services, simply encrypting the data is not enough. Patterns in data access—such as which files are read or written and how often—can reveal sensitive information, even if the data itself is encrypted. This vulnerability is particularly concerning as more data is stored and processed in the cloud, where service providers or malicious attackers may monitor access patterns.&lt;/p&gt;

&lt;p&gt;Oblivious Algorithms addresses the critical privacy gap mentioned above by ensuring that access patterns remain hidden, protecting users from potential information leaks. As a result, Oblivious Algorithms are essential for building secure systems that uphold privacy in sensitive applications like finance, healthcare, and artificial intelligence.&lt;/p&gt;

&lt;h2 id=&quot;examples-of-access-pattern-leakage&quot;&gt;Examples of Access Pattern Leakage&lt;/h2&gt;
&lt;h3 id=&quot;private-contact-discovery&quot;&gt;Private Contact Discovery&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Scenario: Messaging App with Private Contact Discovery&lt;/strong&gt;
A secure messaging app (e.g., Signal, WhatsApp, or Telegram) allows users to discover which of their phone contacts also use the app.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Database Structure: Each entry correponds to a registered user’s phone number and account information.&lt;/li&gt;
  &lt;li&gt;New User Matching Process: When a new user register, users can sync their contacts to check who is on the platform without revealing raw phone numbers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Leakage Due to Unprotected Access Patterns&lt;/strong&gt;
The service provider, government agency, or hacker does not have direct access to the database but can monitor the queries sent by a user when they sync their contacts.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Alice installs the messaging app and syncs her encrypted phone contacts.
    &lt;ul&gt;
      &lt;li&gt;The system queries specific database entries matching some of her contacts’ encrypted phone numbers.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;An observer (e.g., the service provider monitoring the network or a government agency) watches Alice’s access patterns.
    &lt;ul&gt;
      &lt;li&gt;They see that Alice’s device queries entries #5, #12, #28, and #34.&lt;/li&gt;
      &lt;li&gt;These correspond to specific phone numbers already registered in the app.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Consequences of the Leakage&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;🔴 Encryption is not doing anything! The entire social graph is being reconstructed even with encrypted database.&lt;/p&gt;

&lt;h3 id=&quot;kidney-transplantation-records&quot;&gt;Kidney Transplantation Records&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Scenario: A Hospital Managing Kidney Transplants&lt;/strong&gt;
A hospital maintains a highly sensitive database of available kidneys for transplantation. Each kidney entry is linked to metadata such as blood type compatibility, donor status, and urgency levels.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Database Structure: Each entry (e.g., #3, #7, #10) corresponds to a kidney available for transplant.&lt;/li&gt;
  &lt;li&gt;Patient Matching Process: When a new patient arrives needing a transplant, doctors query the database to find a compatible kidney.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Leakage Due to Unprotected Access Patterns&lt;/strong&gt;
An insurance company or an external observer does not have access to the decrypted medical records but can see database queries in real-time.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A new patient is admitted with a suspected kidney issue.&lt;/li&gt;
  &lt;li&gt;The hospital system queries specific database entries (e.g., #3, #7, #10), which correspond to kidney availability.&lt;/li&gt;
  &lt;li&gt;The insurance company observes these access patterns and correlates them with the patient’s recent admission and prescribed medication (e.g., immunosuppressants for transplant patients).&lt;/li&gt;
  &lt;li&gt;Future Accesses Leak More Information:
    &lt;ul&gt;
      &lt;li&gt;Later, the same kidney entries (#3, #7, #10) are accessed again → Suggesting that a patient is progressing toward transplant surgery.&lt;/li&gt;
      &lt;li&gt;If a new entry is accessed instead → Suggests a different patient is now in need of a transplant.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Consequences of the Leakage&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;🔴 Insurance Denial:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The insurance company infers that the patient has end-stage kidney disease and may soon require a costly transplant.&lt;/li&gt;
  &lt;li&gt;They increase premiums or deny coverage before the patient even formally applies.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🔴 Privacy Violation &amp;amp; Targeted Ads:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The patient starts receiving targeted ads for dialysis centers and transplant medications, even though their medical records are encrypted.&lt;/li&gt;
  &lt;li&gt;Their employer, which provides group insurance, may notice these ads and suspect a major health issue, impacting future employment.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🔴 Black Market Risks:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If an external attacker observes that a specific kidney is being accessed repeatedly, they might infer a specific high-priority transplant case is ongoing.&lt;/li&gt;
  &lt;li&gt;This could lead to kidney brokers or criminals targeting the patient or hospital staff.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;oblivious-ram&quot;&gt;Oblivious RAM&lt;/h2&gt;
&lt;p&gt;Oblivious RAM (ORAM) is the most fundamental Oblivious Algorithm – a cryptographic protocol designed to conceal access patterns during data interactions in the simplest abstraction of an array. When clients are accessing an array stored in cloud services, even when data is encrypted, the sequence of operations—such as which entries are accessed and in what order—can inadvertently expose private details.&lt;/p&gt;

&lt;p&gt;ORAM works by introducing randomized access and periodic reshuffling of data, making access patterns indistinguishable from random behavior.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: add some imgs here&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;linear-scan---naive-design-for-oram&quot;&gt;Linear Scan - Naive Design for ORAM&lt;/h3&gt;

&lt;p&gt;The easiest way for designing an ORAM is to do a linear scan of the entire RAM with every read/write access. This is easy to implement, but the operation cost would boost from $O(1)$ to $O(N)$ where $N$ is the size of the RAM.&lt;/p&gt;

&lt;h3 id=&quot;path-oram---a-practical-solution&quot;&gt;Path ORAM - A Practical Solution&lt;/h3&gt;
&lt;p&gt;In 2012, Stefanov and Shi introduced &lt;a href=&quot;https://eprint.iacr.org/2013/280.pdf&quot;&gt;PathORAM&lt;/a&gt;, an efficient and simple ORAM scheme that made ORAM practical.&lt;/p&gt;

&lt;h4 id=&quot;core-idea&quot;&gt;Core Idea&lt;/h4&gt;
&lt;p&gt;PathORAM organizes data into a &lt;strong&gt;binary tree structure&lt;/strong&gt; stored on an untrusted server. The client maintains &lt;strong&gt;a small local stash&lt;/strong&gt; to temporarily store blocks during access operations. The key concept is that each data block is assigned &lt;strong&gt;a random leaf node&lt;/strong&gt; and is always stored along the path from the root to that leaf.
&lt;em&gt;TODO: add imgs&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;operations&quot;&gt;Operations&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Read/Write&lt;/strong&gt;:
    &lt;ol&gt;
      &lt;li&gt;The client downloades the &lt;strong&gt;entire path&lt;/strong&gt; from the root to the leaf associated with the requested block.&lt;/li&gt;
      &lt;li&gt;The client assigns a new random leaf to the block, and the block is modified (if the operation is write).&lt;/li&gt;
      &lt;li&gt;All blocks downloaded are temporarily stored in the stash, along with other blocks on the path.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Eviction&lt;/strong&gt;:
    &lt;ol&gt;
      &lt;li&gt;The client writes back blocks from the stash to the tree, ensuring that blocks always remain within the correct path.&lt;/li&gt;
      &lt;li&gt;Write to the same path as the client downloades the requested block, write in the order from leaf to root&lt;/li&gt;
      &lt;li&gt;For each node, put as many blocks as possible. (Blocks are pushed down the tree as much as possible to maintain efficient storage distribution.)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;security--efficiency&quot;&gt;Security &amp;amp; Efficiency&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Security: Every access pattern looks identical (always fetches a full path), ensuring obliviousness.&lt;/li&gt;
  &lt;li&gt;Bandwidth Overhead: O(log N) per operation, significantly better than earlier schemes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;follow-up-works&quot;&gt;Follow-up Works&lt;/h2&gt;
&lt;p&gt;Since PathORAM, there has been extensive follow-up research on designing ORAM schemes with improved performance under various metrics.&lt;/p&gt;

&lt;p&gt;Additionally, numerous papers, libraries, and implementations exist for other oblivious algorithms, such as oblivious maps and oblivious sorting, many of which leverage ORAM techniques as a foundation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;TODO: is this the right statement? if so, add citations&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As cloud computing becomes the backbone of modern digital infrastructure, ensuring data confidentiality goes beyond simple encryption. The examples of private contact discovery and kidney transplantation records demonstrate that access patterns can reveal highly sensitive information—even when the underlying data remains encrypted. This underscores the necessity of Oblivious Algorithms in protecting user privacy.&lt;/p&gt;

&lt;p&gt;While Path ORAM represents a practical advancement in ORAM design, the field continues to evolve, with researchers striving to improve efficiency, reduce bandwidth overhead, and extend oblivious techniques to broader applications such as secure computation and machine learning. As more organizations recognize the risks of access pattern leakage, integrating Oblivious Algorithms into cloud-based services will be essential for building truly private and secure systems.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ORAM is slow! ... is it?</title>
   <link href="http://localhost:4000/blog/2025/02/12/signal-case-study/"/>
   <updated>2025-02-12T00:00:00-08:00</updated>
   <id>http://localhost:4000/blog/2025/02/12/signal-case-study</id>
   <content type="html">&lt;p&gt;In 2014, the open-source encrypted messaging service Signal began exploring a feature called Private Contact Discovery (PCD). In this post, we trace the long path Signal took to implement PCD in a practical way, ultimately reducing the server infrastructure from hundreds of machines down to just a handful (exact numbers to be confirmed).&lt;/p&gt;

&lt;h4 id=&quot;whats-private-contact-discovery&quot;&gt;What’s Private Contact Discovery&lt;/h4&gt;
&lt;p&gt;Private Contact Discovery (PCD) allows users to find out which of their contacts are already registered on a service—such as a messaging app—without revealing their entire address book to the server. Concretely:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Client has a set of data, called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clientContacts&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Server has a set of data, called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findRegisteredUsers&lt;/code&gt; that access both set of data, and finally return the intersection of both&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In addition, PCD has a few requirements&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Server learns nothing about clients’ contacts that haven’t registered&lt;/li&gt;
  &lt;li&gt;Server learns nothing about clients’ contacts that have registered&lt;/li&gt;
  &lt;li&gt;Clients learns nothing about registered users, except those are their contacts&lt;/li&gt;
  &lt;li&gt;Implementation practical with 10 million registered users&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Current Approach&lt;/strong&gt;: As of the time covered in this post, a common method to fulfill these requirements uses a trusted execution environment (TEE) such as Intel SGX, which isolates the data from the host operating system to ensure privacy.&lt;/p&gt;

&lt;h2 id=&quot;2014-no-solution-works&quot;&gt;2014: No Solution Works&lt;/h2&gt;
&lt;p&gt;In a &lt;a href=&quot;https://signal.org/blog/contact-discovery/&quot;&gt;2014 blog post&lt;/a&gt;  Signal detailed several methods they considered for providing a practical PCD for tens of millions of users with limited download sizes (roughly 2MB). Unfortunately, they found each approach either leaked too much information or was computationally infeasible:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Hash: Because there are only around $10^{10}$ possible phone numbers, the “preimage space” is too small—an attacker could brute force the hashed values.&lt;/li&gt;
  &lt;li&gt;Bloom Filters and Encrypted Bloom Filters: A single Bloom filter for 10 million registered users would be ~40MB, making it too large for routine download to mobile devices.&lt;/li&gt;
  &lt;li&gt;Sharded Bloom Filters: Splitting the data into multiple filters either reveals too much information about individual queries or still involves large data transfers, yielding minimal privacy benefits at significant complexity.&lt;/li&gt;
  &lt;li&gt;Private Set Intersection: Traditional protocols would require the server to perform billions of RSA operations for each client, which is computationally overwhelming.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2017-linear-scan-oram-with-sgx&quot;&gt;2017: Linear Scan ORAM with SGX&lt;/h2&gt;
&lt;p&gt;Let’s fast forward to 2017, Signal team has finally founded a solution to the PCD problem that satisfy all three requirements mentioned above, and it’s through a combination of SGX and linear scan ORAM.&lt;/p&gt;
&lt;h3 id=&quot;whats-sgx&quot;&gt;What’s SGX&lt;/h3&gt;
&lt;p&gt;Intel Software Guard Extensions (SGX) provides a hardware-based security feature that enables trusted execution environments (TEEs), known as enclaves, within a system’s memory. Key SGX properties include:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Attestation&lt;/strong&gt;: Confirms that the code running inside the enclave matches the expected code.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Secure Memory&lt;/strong&gt; – Creates an Enclave Page Cache (EPC) that even the operating system cannot see the data (encrypted or not) stored here.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Memory Encryption&lt;/strong&gt; – Automatically encrypts and decrypts data in untrusted memory, preventing unauthorized access or tampering.
&lt;em&gt;TODO: add some summarization here&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;signals-solution&quot;&gt;Signal’s solution&lt;/h3&gt;
&lt;p&gt;Signal’s solution includes two parts&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;build an oblivious hash table on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clientContacts&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;do a linear scan on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt;. For each registered user, the enclave would do a lookup in the oblivious hash table and update the table for mark a hit or miss.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Both data structures are stored in untrusted memory, but all read/write operations are performed inside the secure SGX enclave. This design ensures that neither the server nor the operating system can infer details about the intersection of contacts.&lt;/p&gt;

&lt;p&gt;To help people better understand, we will explain on the oblivious hash table in the later section, and let’s assume we have a normal hash table for now.&lt;/p&gt;

&lt;h4 id=&quot;linear-scan-on-registered-users&quot;&gt;Linear Scan on Registered Users&lt;/h4&gt;
&lt;p&gt;A straightforward way to discover matches is to iterate over all entries in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; and check each one against the clientContacts hash table:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private List&amp;lt;Long&amp;gt; findRegisteredUsers(List&amp;lt;Long&amp;gt; registeredUsers,
                                       Set&amp;lt;Long&amp;gt; clientContacts)
{
  List&amp;lt;Long&amp;gt; results = new LinkedList&amp;lt;&amp;gt;();

  for (long registeredUser : registeredUsers) {
    if (clientContacts.contains(registeredUser)) {
      results.add(registeredUser);
    }
  }

  return results;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Since this code runs within the enclave, the OS only sees that each entry of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; is accessed once. It cannot tell which entry results in a contacts match, thus preventing the information leakage on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; side.&lt;/p&gt;

&lt;h4 id=&quot;why-a-standard-hash-table-wont-work&quot;&gt;Why a Standard Hash Table Won’t Work&lt;/h4&gt;

&lt;p&gt;Consider the case where we use a normal hash table. When constructing the hash table, the OS can easily see which memory slots are written and which are not. This means that later, when &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findRegisteredUsers&lt;/code&gt; performs a lookup, the OS knows exactly whether it is a match or a miss.&lt;/p&gt;

&lt;p&gt;Additionally, since the server knows which entry in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; is being checked at any given time, it can infer the user’s contacts.&lt;/p&gt;

&lt;h4 id=&quot;what-is-an-oblivious-hash-table&quot;&gt;What Is an Oblivious Hash Table?&lt;/h4&gt;
&lt;p&gt;Instead of a normal hash table, we need one additional feature: the OS should not be able to determine whether a lookup results in a hit or a miss.&lt;/p&gt;

&lt;p&gt;To achieve this, we must touch all possible memory locations in the client’s contact hash table once, storing actual contacts in real memory locations and using dummy entries elsewhere so that the OS cannot distinguish between them.&lt;/p&gt;

&lt;p&gt;Although the construction process is expensive, once built, the OS cannot determine whether a lookup results in a match or a miss in near native time.&lt;/p&gt;
&lt;h4 id=&quot;complexity&quot;&gt;Complexity&lt;/h4&gt;
&lt;p&gt;As one can see, the expensive part of this method is the cost for building the oblivious hash table and the cost for doing a linear scan on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; database.  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; database is the bigger block here with 10 million entires.&lt;/p&gt;

&lt;h2 id=&quot;2022-faster-and-more-efficient-with-path-oram&quot;&gt;2022: Faster and More Efficient with Path ORAM&lt;/h2&gt;
&lt;p&gt;Fast forward to 2022—Signal has surpassed 100 million downloads and urgently needs a faster solution. In 2017, a linear scan was necessary to conceal database access patterns from the server. However, Path ORAM offers a significantly more efficient alternative while being relatively straightforward to implement.&lt;/p&gt;

&lt;p&gt;This new solution includes:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;using Path ORAM to store the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; database,&lt;/li&gt;
  &lt;li&gt;iterate through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clientContacts&lt;/code&gt; and do a binary search in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; database for every entry.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog (&lt;em&gt;TODO: link to the intro to oram blog&lt;/em&gt;) we described how Path ORAM works. Here, we focus on how Path ORAM is constructed and applied to this problem:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;sort all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; based on their phone numbers, and assign the index to that specific user.&lt;/li&gt;
  &lt;li&gt;assign a leaf node for each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; and initialize the ORAM&lt;/li&gt;
  &lt;li&gt;whenever checking a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clientContacts&lt;/code&gt;, do a binary search in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; since the users are sorted&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;By leveraging Path ORAM as the underlying framework, we eliminate the need for linear scans while ensuring that all access patterns remain hidden, even when the database is stored in untrusted memory.&lt;/p&gt;

&lt;h4 id=&quot;complexity-1&quot;&gt;Complexity&lt;/h4&gt;
&lt;p&gt;Assume 1 billion of registered users. In the previous linear scan solution, checking registeredUsers with 1 billion entries required 1 billion operations. With Path ORAM:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Accessing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;registeredUsers&lt;/code&gt; database involves ~30 reads and 30 writes per lookup, as a binary tree with 2 billion nodes has ~30 levels.&lt;/li&gt;
  &lt;li&gt;Performing a binary search for each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clientContacts&lt;/code&gt; entry requires ~30 database accesses.
Thus, the total number of memory accesses is approximately 1,800—a drastic improvement compared to the original 1 billion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;the-final-chapter-a-decade-of-private-contact-discovery&quot;&gt;The Final Chapter: A Decade of Private Contact Discovery&lt;/h2&gt;
&lt;p&gt;After 10 years, private contact discovery finally has a near-native implementation. While ORAM is undeniably slower than non-private solutions, its performance has often been misunderstood—exaggerated as impractically slow.&lt;/p&gt;

&lt;p&gt;Signal had already explored Path ORAM in 2017, but due to an incorrect implementation and lack of optimization, they underestimated its potential. Now, we present Oblivious STL, a standardized, optimized implementation that helps the broader audience understand the true cost of privacy—and how feasible it really is.&lt;/p&gt;

</content>
 </entry>
 

</feed>
